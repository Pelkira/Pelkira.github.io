<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ヘイブン/アタッカー</title>
    <style>
        body {
            background-color: #1a1a1a;
            color: #f0f0f0;
            margin: 0;
            padding: 20px;
            font-family: Arial, sans-serif;
        }
        #imageContainer {
            position: relative;
            display: inline-block;
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
        }
        #arrowCanvas {
            position: absolute;
            top: 0;
            left: 0;
        }
    </style>
</head>
<body>
    <div id="imageContainer">
        <img id="mainImage" src="images/Haven.png" alt="メイン画像">
        <canvas id="arrowCanvas"></canvas>
    </div>

    <script>
        const img = document.getElementById('mainImage');
        const canvas = document.getElementById('arrowCanvas');
        const ctx = canvas.getContext('2d');

        let arrows = [];

        img.onload = function() {
            canvas.width = img.width;
            canvas.height = img.height;
            addArrow(100, 100, 300, 300, 'https://example.com');
            addArrow(200, 200, 400, 100, 'https://example.org');
            drawArrows();
        };

        function addArrow(fromx, fromy, tox, toy, url) {
            arrows.push({fromx, fromy, tox, toy, url, hover: false});
        }
        function drawArrows() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            arrows.forEach(arrow => drawArrow(arrow));
        }


        function drawArrow(arrow) {
            const {fromx, fromy, tox, toy, hover} = arrow;
            const headlen = 20;
            const angle = Math.atan2(toy-fromy, tox-fromx);

            // 矢印の終点を三角形の根元に調整
            const adjustedTox = tox - headlen * Math.cos(angle);
            const adjustedToy = toy - headlen * Math.sin(angle);

            // 矢印の本体
            ctx.beginPath();
            ctx.moveTo(fromx, fromy);
            ctx.lineTo(adjustedTox, adjustedToy);
            ctx.strokeStyle = hover ? '#00FFFF' : '#FF69B4'; // シアン（ホバー時）、ホットピンク（通常時）
            ctx.lineWidth = 4;
            ctx.stroke();

            // 矢印の頭
            ctx.beginPath();
            ctx.moveTo(tox, toy);
            ctx.lineTo(tox-headlen*Math.cos(angle-Math.PI/6), toy-headlen*Math.sin(angle-Math.PI/6));
            ctx.lineTo(tox-headlen*Math.cos(angle+Math.PI/6), toy-headlen*Math.sin(angle+Math.PI/6));
            ctx.closePath();
            ctx.fillStyle = hover ? '#00FFFF' : '#FF69B4';
            ctx.fill();

            // グロー効果
            if (hover) {
                ctx.shadowColor = '#00FFFF';
                ctx.shadowBlur = 15;
                ctx.stroke();
                ctx.fill();
                ctx.shadowBlur = 0;
            }
        }

        canvas.onmousemove = function(e) {
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            let hoveredArrows = arrows.filter(arrow => 
                isPointOnLine(arrow.fromx, arrow.fromy, arrow.tox, arrow.toy, x, y, 5)
            );

            let redraw = false;
            arrows.forEach(arrow => {
                let newHoverState = hoveredArrows.length > 0 && arrow === hoveredArrows[hoveredArrows.length - 1];
                if (arrow.hover !== newHoverState) {
                    arrow.hover = newHoverState;
                    redraw = true;
                }
            });

            if (redraw) {
                drawArrows();
            }

            canvas.style.cursor = hoveredArrows.length > 0 ? 'pointer' : 'default';
        };

        canvas.onclick = function(e) {
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            let clickedArrows = arrows.filter(arrow => 
                isPointOnLine(arrow.fromx, arrow.fromy, arrow.tox, arrow.toy, x, y, 5)
            );

            if (clickedArrows.length > 0) {
                window.location.href = clickedArrows[clickedArrows.length - 1].url;
            }
        };

        function isPointOnLine(x1, y1, x2, y2, px, py, tolerance) {
            const A = px - x1;
            const B = py - y1;
            const C = x2 - x1;
            const D = y2 - y1;

            const dot = A * C + B * D;
            const len_sq = C * C + D * D;
            const param = dot / len_sq;

            let xx, yy;

            if (param < 0) {
                xx = x1;
                yy = y1;
            }
            else if (param > 1) {
                xx = x2;
                yy = y2;
            }
            else {
                xx = x1 + param * C;
                yy = y1 + param * D;
            }

            const dx = px - xx;
            const dy = py - yy;
            const distance = Math.sqrt(dx * dx + dy * dy);

            return distance <= tolerance;
        }
    </script>
</body>
</html>
